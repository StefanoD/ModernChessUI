#pragma once

#include "BitBoardConstants.h"
#include "ModernChess/BitBoardOperations.h"
#include "PawnPushes.h"
#include "Square.h"
#include "Figure.h"

#include <array>

namespace ModernChess {

    namespace RookAttackHelperFunctions {

        namespace RookMetaData
        {
            // rook relevant occupancy bit count for every square on board
            // This has been generated by printing the result of
            // BitBoardOperations::countBits(Attacks::SlidingPieces::maskRookAttacks(square)))
            // for every square
            constexpr std::array<uint32_t, 64> relevantBits{
                    12, 11, 11, 11, 11, 11, 11, 12,
                    11, 10, 10, 10, 10, 10, 10, 11,
                    11, 10, 10, 10, 10, 10, 10, 11,
                    11, 10, 10, 10, 10, 10, 10, 11,
                    11, 10, 10, 10, 10, 10, 10, 11,
                    11, 10, 10, 10, 10, 10, 10, 11,
                    11, 10, 10, 10, 10, 10, 10, 11,
                    12, 11, 11, 11, 11, 11, 11, 12
            };

            // Generated by test/MagicNumberCandidateGeneration.cpp
            constexpr std::array<uint64_t, 64> magicNumbers{
                    0x8a80104000800020ULL,
                    0x140002000100040ULL,
                    0x2801880a0017001ULL,
                    0x100081001000420ULL,
                    0x200020010080420ULL,
                    0x3001c0002010008ULL,
                    0x8480008002000100ULL,
                    0x2080088004402900ULL,
                    0x800098204000ULL,
                    0x2024401000200040ULL,
                    0x100802000801000ULL,
                    0x120800800801000ULL,
                    0x208808088000400ULL,
                    0x2802200800400ULL,
                    0x2200800100020080ULL,
                    0x801000060821100ULL,
                    0x80044006422000ULL,
                    0x100808020004000ULL,
                    0x12108a0010204200ULL,
                    0x140848010000802ULL,
                    0x481828014002800ULL,
                    0x8094004002004100ULL,
                    0x4010040010010802ULL,
                    0x20008806104ULL,
                    0x100400080208000ULL,
                    0x2040002120081000ULL,
                    0x21200680100081ULL,
                    0x20100080080080ULL,
                    0x2000a00200410ULL,
                    0x20080800400ULL,
                    0x80088400100102ULL,
                    0x80004600042881ULL,
                    0x4040008040800020ULL,
                    0x440003000200801ULL,
                    0x4200011004500ULL,
                    0x188020010100100ULL,
                    0x14800401802800ULL,
                    0x2080040080800200ULL,
                    0x124080204001001ULL,
                    0x200046502000484ULL,
                    0x480400080088020ULL,
                    0x1000422010034000ULL,
                    0x30200100110040ULL,
                    0x100021010009ULL,
                    0x2002080100110004ULL,
                    0x202008004008002ULL,
                    0x20020004010100ULL,
                    0x2048440040820001ULL,
                    0x101002200408200ULL,
                    0x40802000401080ULL,
                    0x4008142004410100ULL,
                    0x2060820c0120200ULL,
                    0x1001004080100ULL,
                    0x20c020080040080ULL,
                    0x2935610830022400ULL,
                    0x44440041009200ULL,
                    0x280001040802101ULL,
                    0x2100190040002085ULL,
                    0x80c0084100102001ULL,
                    0x4024081001000421ULL,
                    0x20030a0244872ULL,
                    0x12001008414402ULL,
                    0x2006104900a0804ULL,
                    0x1004081002402ULL
            };
        };

        // mask rook attacks
        [[nodiscard]] constexpr BitBoardState maskRookAttacks(Square square)
        {
            // result attacks bitboard
            BitBoardState attacks = BoardState::empty;

            // init target rank & files
            const int targetRank = square / 8;
            const int targetFile = square % 8;

            // init ranks & files
            int rank;
            int file;

            // mask relevant bishop occupancy bits
            for (rank = targetRank + 1; rank <= 6; ++rank)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(rank, targetFile);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);
            }

            for (rank = targetRank - 1; rank >= 1; --rank)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(rank, targetFile);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);
            }

            for (file = targetFile + 1; file <= 6; ++file)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(targetRank, file);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);
            }

            for (file = targetFile - 1; file >= 1; --file)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(targetRank, file);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);
            }

            // return attack map
            return attacks;
        }

        // generate rook attacks on the fly
        [[nodiscard]] constexpr BitBoardState rookAttacksOnTheFly(BitBoardState occupiedSquares, Square square)
        {
            // result attacks bitboard
            BitBoardState attacks = BoardState::empty;

            // init target rank & files
            const int targetRank = square / 8;
            const int targetFile = square % 8;

            // init ranks & files
            int rank;
            int file;

            // generate rook attacks
            for (rank = targetRank + 1; rank <= 7; ++rank)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(rank, targetFile);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);

                if (BitBoardOperations::isOccupied(occupiedSquares, attackedSquare))
                {
                    break;
                }
            }

            for (rank = targetRank - 1; rank >= 0; --rank)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(rank, targetFile);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);

                if (BitBoardOperations::isOccupied(occupiedSquares, attackedSquare))
                {
                    break;
                }
            }

            for (file = targetFile + 1; file <= 7; ++file)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(targetRank, file);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);

                if (BitBoardOperations::isOccupied(occupiedSquares, attackedSquare))
                {
                    break;
                }
            }

            for (file = targetFile - 1; file >= 0; --file)
            {
                const Square attackedSquare = BitBoardOperations::getSquare(targetRank, file);
                attacks = BitBoardOperations::occupySquare(attacks, attackedSquare);

                if (BitBoardOperations::isOccupied(occupiedSquares, attackedSquare))
                {
                    break;
                }
            }

            // return attack map
            return attacks;
        }
    }

    class RookAttacks {
    public:
        RookAttacks();

        [[nodiscard]] inline BitBoardState getAttacks(Square square, BitBoardState occupiedSquares) const
        {
            occupiedSquares &= attackMasks[square];
            occupiedSquares *= RookAttackHelperFunctions::RookMetaData::magicNumbers[square];
            occupiedSquares >>= 64 - RookAttackHelperFunctions::RookMetaData::relevantBits[square];

            return rookAttacks[square][occupiedSquares];
        }
    private:
        // rook attack masks
        std::array<BitBoardState, 64> attackMasks{};

        // rook attacks table [square][occupancies]
        std::array<std::array<BitBoardState, 4096>, 64>  rookAttacks{};
    };
}